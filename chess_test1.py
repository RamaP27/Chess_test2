# -*- coding: utf-8 -*-
"""Chess_test1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nD9C7fspATTwGHkYrPOqc9OVMSQUIdKn
"""

class ChessBoard:
    def __init__(self):
        self.rows = list('12345678')
        self.cols = list('ABCDEFGH')

    def is_valid_position(self, row, col):
        """ Check if the position is within the chessboard limits """
        return row in self.rows and col in self.cols

    def get_possible_moves(self, piece, position):
        """ Get all possible moves based on the piece and current position """
        row, col = position[1], position[0]
        if not self.is_valid_position(row, col):
            raise ValueError("Invalid Position")

        piece = piece.lower()
        if piece == 'pawn':
            return self.get_pawn_moves(row, col)
        elif piece == 'king':
            return self.get_king_moves(row, col)
        elif piece == 'queen':
            return self.get_queen_moves(row, col)
        else:
            raise ValueError("Unknown Piece")

    def get_pawn_moves(self, row, col):
        """ Get possible moves for a pawn (1 step forward) """
        moves = []
        row_idx = self.rows.index(row)
        col_idx = self.cols.index(col)
        if row_idx + 1 < 8:  # Move forward by 1
            moves.append(self.cols[col_idx] + self.rows[row_idx + 1])
        return moves

    def get_king_moves(self, row, col):
        """ Get all possible moves for the King (1 step in all directions) """
        moves = []
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]
        row_idx = self.rows.index(row)
        col_idx = self.cols.index(col)
        for dr, dc in directions:
            new_row_idx = row_idx + dr
            new_col_idx = col_idx + dc
            if 0 <= new_row_idx < 8 and 0 <= new_col_idx < 8:
                moves.append(self.cols[new_col_idx] + self.rows[new_row_idx])
        return moves

    def get_queen_moves(self, row, col):
        """ Get all possible moves for the Queen (vertical, horizontal, diagonal) """
        moves = []
        moves.extend(self.get_rook_moves(row, col))
        moves.extend(self.get_bishop_moves(row, col))
        return moves

    def get_rook_moves(self, row, col):
        """ Rook moves (horizontal and vertical) """
        moves = []
        row_idx = self.rows.index(row)
        col_idx = self.cols.index(col)

        # Vertical moves
        for i in range(8):
            if i != row_idx:
                moves.append(self.cols[col_idx] + self.rows[i])

        # Horizontal moves
        for i in range(8):
            if i != col_idx:
                moves.append(self.cols[i] + self.rows[row_idx])

        return moves

    def get_bishop_moves(self, row, col):
        """ Bishop moves (diagonal) """
        moves = []
        row_idx = self.rows.index(row)
        col_idx = self.cols.index(col)

        # Diagonal moves (top-right, bottom-left, top-left, bottom-right)
        for dr, dc in [(1, 1), (-1, -1), (1, -1), (-1, 1)]:
            new_row_idx, new_col_idx = row_idx, col_idx
            while True:
                new_row_idx += dr
                new_col_idx += dc
                if 0 <= new_row_idx < 8 and 0 <= new_col_idx < 8:
                    moves.append(self.cols[new_col_idx] + self.rows[new_row_idx])
                else:
                    break
        return moves


# Example usage
if __name__ == "__main__":
    board = ChessBoard()
    piece, position = input("Enter piece and position (e.g. King, D5): ").split(", ")
    possible_moves = board.get_possible_moves(piece, position)
    print("Possible moves:", ", ".join(possible_moves))

class ChessBoard:
    def __init__(self):
        self.rows = list('12345678')
        self.cols = list('ABCDEFGH')

    def is_valid_position(self, row, col):
        """ Check if the position is within the chessboard limits """
        return row in self.rows and col in self.cols

    def get_possible_moves(self, piece, position):
        """ Get all possible moves based on the piece and current position """
        row, col = position[1], position[0]
        if not self.is_valid_position(row, col):
            raise ValueError("Invalid Position")

        piece = piece.lower()
        if piece == 'pawn':
            return self.get_pawn_moves(row, col)
        elif piece == 'king':
            return self.get_king_moves(row, col)
        elif piece == 'queen':
            return self.get_queen_moves(row, col)
        else:
            raise ValueError("Unknown Piece")

    def get_pawn_moves(self, row, col):
        """ Get possible moves for a pawn (1 step forward) """
        moves = []
        row_idx = self.rows.index(row)
        col_idx = self.cols.index(col)
        if row_idx + 1 < 8:  # Move forward by 1
            moves.append(self.cols[col_idx] + self.rows[row_idx + 1])
        return moves

    def get_king_moves(self, row, col):
        """ Get all possible moves for the King (1 step in all directions) """
        moves = []
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]
        row_idx = self.rows.index(row)
        col_idx = self.cols.index(col)
        for dr, dc in directions:
            new_row_idx = row_idx + dr
            new_col_idx = col_idx + dc
            if 0 <= new_row_idx < 8 and 0 <= new_col_idx < 8:
                moves.append(self.cols[new_col_idx] + self.rows[new_row_idx])
        return moves

    def get_queen_moves(self, row, col):
        """ Get all possible moves for the Queen (vertical, horizontal, diagonal) """
        moves = []
        moves.extend(self.get_rook_moves(row, col))
        moves.extend(self.get_bishop_moves(row, col))
        return moves

    def get_rook_moves(self, row, col):
        """ Rook moves (horizontal and vertical) """
        moves = []
        row_idx = self.rows.index(row)
        col_idx = self.cols.index(col)

        # Vertical moves
        for i in range(8):
            if i != row_idx:
                moves.append(self.cols[col_idx] + self.rows[i])

        # Horizontal moves
        for i in range(8):
            if i != col_idx:
                moves.append(self.cols[i] + self.rows[row_idx])

        return moves

    def get_bishop_moves(self, row, col):
        """ Bishop moves (diagonal) """
        moves = []
        row_idx = self.rows.index(row)
        col_idx = self.cols.index(col)

        # Diagonal moves (top-right, bottom-left, top-left, bottom-right)
        for dr, dc in [(1, 1), (-1, -1), (1, -1), (-1, 1)]:
            new_row_idx, new_col_idx = row_idx, col_idx
            while True:
                new_row_idx += dr
                new_col_idx += dc
                if 0 <= new_row_idx < 8 and 0 <= new_col_idx < 8:
                    moves.append(self.cols[new_col_idx] + self.rows[new_row_idx])
                else:
                    break
        return moves


# Example usage
if __name__ == "__main__":
    board = ChessBoard()
    try:
        input_data = input("Enter piece and position (e.g. King, D5): ")
        if ", " not in input_data:
            raise ValueError("Invalid input format. Please use the format 'Piece, Position' (e.g., 'King, D5').")
        piece, position = input_data.split(", ")
        possible_moves = board.get_possible_moves(piece, position)
        print("Possible moves:", ", ".join(possible_moves))
    except ValueError as ve:
        print(f"Error: {ve}")